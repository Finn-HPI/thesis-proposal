\section{Goal of Thesis}
\label{sec:goal}

% Description of the concrete problems addressed as the goals of the thesis, planned/expected results, reference to other thesis, paper, etc., if any.

This thesis aims to efficiently implement the sort-merge join algorithm,
explicitly optimized for specific architectures and hardware components. While multiple papers
exist about modern implementation approaches for sort-merge joins in in-memory database systems
and SIMD sorting generally, only some have public 
implementations\footnote{Implementation of \cite{Balkesen} published at \url{https://archive-systems.ethz.ch/node/334}}.
Most SIMD sorting algorithms
presented in the literature are not directly applicable to join operations as they usually use
sorting keys of only 32 bits. We must additionally track the row ID (rid) corresponding to the search key for
a joini, requiring at least 64-bit elements. The current implementations of sort-merge join in literature use SSE and AVX2 intrinsics,
but to our knowledge, there has yet to be an implementation using AVX512. Therefore, in the scope
of this thesis, we want to integrate support for modern AVX512 sorting algorithms (\cite{Watkins}, \cite{8855628})
next to SSE and AVX2 into a complete sort-merge join operator.
It would also be of value to see how existing and new approaches transfer to other
CPU architectures like Arm with its Scalable Vector Extension (SVE). While some public implementations
exist for modern and optimized sort-merge join, they have usually isolated implementations with a strong
focus on the sorting step using randomly chosen input data, often already in the required data format. 
Also, they often skip the lookup of matching rows and the construction of the joined table.
Hence, in this thesis, we want to integrate our implementation of the sort-merge join into Hyrise
\cite{DBLP:conf/edbt/DreselerK0KUP19},
a research in-memory database. Hyrise contains both a radix-based Hash-Join and sort-merge join.
The sort-merge join uses radix cluster sorting, which uses pattern-defeating quicksort (boost)
but no explicit SIMD instructions. It fundamentally differs from the modern approaches in the literature.
These differences allow us to test our implementation against the existing sort-merge and hash-based join.
Complete integration into an in-memory database allows us to run decision support benchmarks
like TCP-H or TCP-DS to compare our sort-merge operator to other implementations in a more realistic scenario.
Benchmarking should also include measuring the sorting throughput in tuples per second and all 
algorithmic steps: initial data construction in the format of (key, rid) from the input relations,
sorting, finding join partners, and the final construction of the joined table. 
We want to test our implementation on different architectures and hardware, evaluating
differences in core count, cache size, SIMD registers with different widths, NUMA regions, 
and other hardware-specific properties.
