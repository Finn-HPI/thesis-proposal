@article{MPSM,
  author = {Albutiu, Martina-Cezara and Kemper, Alfons and Neumann, Thomas},
  title = {Massively parallel sort-merge joins in main memory multi-core
           database systems},
  year = {2012},
  issue_date = {June 2012},
  publisher = {VLDB Endowment},
  volume = {5},
  number = {10},
  issn = {2150-8097},
  url = {https://doi.org/10.14778/2336664.2336678},
  doi = {10.14778/2336664.2336678},
  abstract = {Two emerging hardware trends will dominate the database system
              technology in the near future: increasing main memory capacities of
              several TB per server and massively parallel multi-core processing.
              Many algorithmic and control techniques in current database
              technology were devised for disk-based systems where I/O dominated
              the performance. In this work we take a new look at the well-known
              sort-merge join which, so far, has not been in the focus of
              research in scalable massively parallel multi-core data processing
              as it was deemed inferior to hash joins. We devise a suite of new
              massively parallel sort-merge (MPSM) join algorithms that are based
              on partial partition-based sorting. Contrary to classical
              sort-merge joins, our MPSM algorithms do not rely on a hard to
              parallelize final merge step to create one complete sort order.
              Rather they work on the independently created runs in parallel.
              This way our MPSM algorithms are NUMA-affine as all the sorting is
              carried out on local memory partitions. An extensive experimental
              evaluation on a modern 32-core machine with one TB of main memory
              proves the competitive performance of MPSM on large main memory
              databases with billions of objects. It scales (almost) linearly in
              the number of employed cores and clearly outperforms competing hash
              join proposals -- in particular it outperforms the "cutting-edge"
              Vectorwise parallel query engine by a factor of four.},
  journal = {Proc. VLDB Endow.},
  month = {jun},
  pages = {1064–1075},
  numpages = {12},
}
  
@article{Balkesen,
  author = {Balkesen, Cagri and Alonso, Gustavo and Teubner, Jens and \"{O}zsu,
            M. Tamer},
  title = {Multi-core, main-memory joins: sort vs. hash revisited},
  year = {2013},
  issue_date = {September 2013},
  publisher = {VLDB Endowment},
  volume = {7},
  number = {1},
  issn = {2150-8097},
  url = {https://doi.org/10.14778/2732219.2732227},
  doi = {10.14778/2732219.2732227},
  abstract = {In this paper we experimentally study the performance of
              main-memory, parallel, multi-core join algorithms, focusing on
              sort-merge and (radix-)hash join. The relative performance of these
              two join approaches have been a topic of discussion for a long
              time. With the advent of modern multi-core architectures, it has
              been argued that sort-merge join is now a better choice than
              radix-hash join. This claim is justified based on the width of SIMD
              instructions (sort-merge outperforms radix-hash join once SIMD is
              sufficiently wide), and NUMA awareness (sort-merge is superior to
              hash join in NUMA architectures). We conduct extensive experiments
              on the original and optimized versions of these algorithms. The
              experiments show that, contrary to these claims, radix-hash join is
              still clearly superior, and sort-merge approaches to performance of
              radix only when very large amounts of data are involved. The paper
              also provides the fastest implementations of these algorithms, and
              covers many aspects of modern hardware architectures relevant not
              only for joins but for any parallel data processing operator.},
  journal = {Proc. VLDB Endow.},
  month = {sep},
  pages = {85–96},
  numpages = {12},
}

@article{10.14778/1454159.1454171,
  author = {Chhugani, Jatin and Nguyen, Anthony D. and Lee, Victor W. and Macy,
            William and Hagog, Mostafa and Chen, Yen-Kuang and Baransi, Akram and
            Kumar, Sanjeev and Dubey, Pradeep},
  title = {Efficient implementation of sorting on multi-core SIMD CPU
           architecture},
  year = {2008},
  issue_date = {August 2008},
  publisher = {VLDB Endowment},
  volume = {1},
  number = {2},
  issn = {2150-8097},
  url = {https://doi.org/10.14778/1454159.1454171},
  doi = {10.14778/1454159.1454171},
  abstract = {Sorting a list of input numbers is one of the most fundamental
              problems in the field of computer science in general and
              high-throughput database applications in particular. Although
              literature abounds with various flavors of sorting algorithms,
              different architectures call for customized implementations to
              achieve faster sorting times.This paper presents an efficient
              implementation and detailed analysis of MergeSort on current CPU
              architectures. Our SIMD implementation with 128-bit SSE is 3.3X
              faster than the scalar version. In addition, our algorithm performs
              an efficient multiway merge, and is not constrained by the memory
              bandwidth. Our multi-threaded, SIMD implementation sorts 64 million
              floating point numbers in less than0.5 seconds on a commodity
              4-core Intel processor. This measured performance compares
              favorably with all previously published results.Additionally, the
              paper demonstrates performance scalability of the proposed sorting
              algorithm with respect to certain salient architectural features of
              modern chip multiprocessor (CMP) architectures, including SIMD
              width and core-count. Based on our analytical models of various
              architectural configurations, we see excellent scalability of our
              implementation with SIMD width scaling up to 16X wider than current
              SSE width of 128-bits, and CMP core-count scaling well beyond 32
              cores. Cycle-accurate simulation of Intel's upcoming x86 many-core
              Larrabee architecture confirms scalability of our proposed
              algorithm.},
  journal = {Proc. VLDB Endow.},
  month = {aug},
  pages = {1313–1324},
  numpages = {12},
}

@inproceedings{10.1145/1989323.1989328,
  author = {Blanas, Spyros and Li, Yinan and Patel, Jignesh M.},
  title = {Design and evaluation of main memory hash join algorithms for
           multi-core CPUs},
  year = {2011},
  isbn = {9781450306614},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1989323.1989328},
  doi = {10.1145/1989323.1989328},
  abstract = {The focus of this paper is on investigating efficient hash join
              algorithms for modern multi-core processors in main memory
              environments. This paper dissects each internal phase of a typical
              hash join algorithm and considers different alternatives for
              implementing each phase, producing a family of hash join
              algorithms. Then, we implement these main memory algorithms on two
              radically different modern multi-processor systems, and carefully
              examine the factors that impact the performance of each method.Our
              analysis reveals some interesting results -- a very simple hash
              join algorithm is very competitive to the other more complex
              methods. This simple join algorithm builds a shared hash table and
              does not partition the input relations. Its simplicity implies that
              it requires fewer parameter settings, thereby making it far easier
              for query optimizers and execution engines to use it in practice.
              Furthermore, the performance of this simple algorithm improves
              dramatically as the skew in the input data increases, and it
              quickly starts to outperform all other algorithms.},
  booktitle = {Proceedings of the 2011 ACM SIGMOD International Conference on
               Management of Data},
  pages = {37–48},
  numpages = {12},
  keywords = {hash join, main memory, multi-core},
  location = {Athens, Greece},
  series = {SIGMOD '11},
}

@article{10.14778/1687553.1687564,
  author = {Kim, Changkyu and Kaldewey, Tim and Lee, Victor W. and Sedlar, Eric
            and Nguyen, Anthony D. and Satish, Nadathur and Chhugani, Jatin and
            Di Blas, Andrea and Dubey, Pradeep},
  title = {Sort vs. Hash revisited: fast join implementation on modern
           multi-core CPUs},
  year = {2009},
  issue_date = {August 2009},
  publisher = {VLDB Endowment},
  volume = {2},
  number = {2},
  issn = {2150-8097},
  url = {https://doi.org/10.14778/1687553.1687564},
  doi = {10.14778/1687553.1687564},
  abstract = {Join is an important database operation. As computer architectures
              evolve, the best join algorithm may change hand. This paper
              re-examines two popular join algorithms -- hash join and sort-merge
              join -- to determine if the latest computer architecture trends
              shift the tide that has favored hash join for many years. For a
              fair comparison, we implemented the most optimized parallel version
              of both algorithms on the latest Intel Core i7 platform. Both
              implementations scale well with the number of cores in the system
              and take advantages of latest processor features for performance.
              Our hash-based implementation achieves more than 100M tuples per
              second which is 17X faster than the best reported performance on
              CPUs and 8X faster than that reported for GPUs. Moreover, the
              performance of our hash join implementation is consistent over a
              wide range of input data sizes from 64K to 128M tuples and is not
              affected by data skew. We compare this implementation to our highly
              optimized sort-based implementation that achieves 47M to 80M tuples
              per second. We developed analytical models to study how both
              algorithms would scale with upcoming processor architecture trends.
              Our analysis projects that current architectural trends of wider
              SIMD, more cores, and smaller memory bandwidth per core imply
              better scalability potential for sort-merge join. Consequently,
              sort-merge join is likely to outperform hash join on upcoming chip
              multiprocessors. In summary, we offer multicore implementations of
              hash join and sort-merge join which consistently outperform all
              previously reported results. We further conclude that the tide that
              favors the hash join algorithm has not changed yet, but the change
              is just around the corner.},
  journal = {Proc. VLDB Endow.},
  month = {aug},
  pages = {1378–1389},
  numpages = {12},
}

@inproceedings{Watkins,
  author = {Watkins, Alex and Green, Oded},
  year = {2018},
  month = {11},
  pages = {},
  title = {A Fast and Simple Approach to Merge and Merge Sort Using Wide Vector
           Instructions},
  doi = {10.1109/IA3.2018.00012},
}

@inproceedings{MergePath,
  author = {Odeh, Saher and Green, Oded and Mwassi, Zahi and Shmueli, Oz and
            Birk, Yitzhak},
  year = {2012},
  month = {05},
  pages = {1611-1618},
  title = {Merge Path - Parallel Merging Made Simple},
  isbn = {978-1-4673-0974-5},
  journal = {Proceedings of the 2012 IEEE 26th International Parallel and
             Distributed Processing Symposium Workshops, IPDPSW 2012},
  doi = {10.1109/IPDPSW.2012.202},
}

@inproceedings{10.1145/1468075.1468121,
  author = {Batcher, K. E.},
  title = {Sorting networks and their applications},
  year = {1968},
  isbn = {9781450378970},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1468075.1468121},
  doi = {10.1145/1468075.1468121},
  abstract = {To achieve high throughput rates today's computers perform several
              operations simultaneously. Not only are I/O operations performed
              concurrently with computing, but also, in multiprocessors, several
              computing operations are done concurrently. A major problem in the
              design of such a computing system is the connecting together of the
              various parts of the system (the I/O devices, memories, processing
              units, etc.) in such a way that all the required data transfers can
              be accommodated. One common scheme is a high-speed bus which is
              time-shared by the various parts; speed of available hardware
              limits this scheme. Another scheme is a cross-bar switch or matrix;
              limiting factors here are the amount of hardware (an m \texttimes{}
              n matrix requires m \texttimes{} n cross-points) and the fan-in and
              fan-out of the hardware.},
  booktitle = {Proceedings of the April 30--May 2, 1968, Spring Joint Computer
               Conference},
  pages = {307–314},
  numpages = {8},
  location = {Atlantic City, New Jersey},
  series = {AFIPS '68 (Spring)},
}

@inproceedings{4336211,
  author = {Inoue, Hiroshi and Moriyama, Takao and Komatsu, Hideaki and Nakatani
            , Toshio},
  booktitle = {16th International Conference on Parallel Architecture and
               Compilation Techniques (PACT 2007)},
  title = {AA-Sort: A New Parallel Sorting Algorithm for Multi-Core SIMD
           Processors},
  year = {2007},
  volume = {},
  number = {},
  pages = {189-198},
  keywords = {Sorting;Scalability;Yarn;Libraries;Acceleration;Parallel
              processing;Pipelines;Computational complexity;Laboratories;Engines},
  doi = {10.1109/PACT.2007.4336211},
}

% key prefix
@misc{chris_nyberg__1994,
  title = { AlphaSort: a RISC machine sort },
  author = { Chris Nyberg and Tom Barclay and Zarka Cvetanovic and Jim Gray and
            Dave Lomet },
  year = { 1994 },
  publisher = { ACM },
  volume = { 23 },
  pages = { 233-242 },
  number = { 2 },
  doi = { 10.1145/191839.191884 },
}

% XOR/shift hash function
@inproceedings{1319989,
  author = {Chen, S. and Ailamaki, A. and Gibbons, P.B. and Mowry, T.C.},
  booktitle = {Proceedings. 20th International Conference on Data Engineering},
  title = {Improving hash join performance through prefetching},
  year = {2004},
  volume = {},
  number = {},
  pages = {116-127},
  keywords = {Prefetching;Probes;Partitioning algorithms;Electric
              breakdown;Database systems;Costs;Delay},
  doi = {10.1109/ICDE.2004.1319989},
}

@inproceedings{8855628,
  author = {Yin, Zekun and Zhang, Tianyu and Müller, André and Liu, Hui and Wei,
            Yanjie and Schmidt, Bertil and Liu, Weiguo},
  booktitle = {2019 IEEE 21st International Conference on High Performance
               Computing and Communications; IEEE 17th International Conference
               on Smart City; IEEE 5th International Conference on Data Science
               and Systems (HPCC/SmartCity/DSS)},
  title = {Efficient Parallel Sort on AVX-512-Based Multi-Core and Many-Core
           Architectures},
  year = {2019},
  volume = {},
  number = {},
  pages = {168-176},
  keywords = {Sorting;Program processors;Computer
              architecture;Bandwidth;Merging;Kernel;Parallel processing;Sort, KNL
              , Skylate-EP, AVX512, Merge Sort, Bitonic Sort},
  doi = {10.1109/HPCC/SmartCity/DSS.2019.00038},
}

@inproceedings{DBLP:conf/edbt/DreselerK0KUP19,
  author = {Markus Dreseler and Jan Kossmann and Martin Boissier and Stefan
            Klauck and Matthias Uflacker and Hasso Plattner},
  editor = {Melanie Herschel and Helena Galhardas and Berthold Reinwald and
            Irini Fundulaki and Carsten Binnig and Zoi Kaoudi},
  title = {Hyrise Re-engineered: An Extensible Database System for Research in
           Relational In-Memory Data Management},
  booktitle = {Advances in Database Technology - 22nd International Conference
               on Extending Database Technology, {EDBT} 2019, Lisbon, Portugal,
               March 26-29, 2019},
  pages = {313--324},
  publisher = {OpenProceedings.org},
  year = {2019},
  url = {https://doi.org/10.5441/002/edbt.2019.28},
  doi = {10.5441/002/edbt.2019.28},
  timestamp = {Mon, 18 Mar 2019 16:09:00 +0100},
  biburl = {https://dblp.org/rec/conf/edbt/DreselerK0KUP19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
}
